// app/architecture/generators/allGenerators.ts

import type { ArchitectureData } from '../types';

// Sanitize text for Mermaid diagrams - AGGRESSIVE sanitization for complex text
function sanitizeForMermaid(text: string): string {
  if (!text) return '';

  return text
    // STEP 1: First collapse all whitespace (newlines, tabs, multiple spaces)
    .replace(/[\n\r\t]+/g, ' ')         // All whitespace chars to single space
    .replace(/\s+/g, ' ')               // Collapse multiple spaces

    // STEP 2: Remove or escape problematic characters for Mermaid syntax
    .replace(/"/g, "'")                 // Double quotes ‚Üí single quotes
    .replace(/\|/g, '/')                // Pipes ‚Üí slashes
    .replace(/>/g, '')                  // Greater than ‚Üí remove
    .replace(/</g, '')                  // Less than ‚Üí remove
    .replace(/\(/g, '')                 // Open parenthesis ‚Üí remove
    .replace(/\)/g, '')                 // Close parenthesis ‚Üí remove
    .replace(/\[/g, '')                 // Open bracket ‚Üí remove
    .replace(/\]/g, '')                 // Close bracket ‚Üí remove
    .replace(/\{/g, '')                 // Open brace ‚Üí remove
    .replace(/\}/g, '')                 // Close brace ‚Üí remove
    .replace(/:/g, ' ')                 // Colons ‚Üí space
    .replace(/;/g, ' ')                 // Semicolons ‚Üí space
    .replace(/,/g, ' ')                 // Commas ‚Üí space
    .replace(/\./g, ' ')                // Periods ‚Üí space
    .replace(/[-‚Äì‚Äî]/g, ' ')             // All dashes ‚Üí space
    .replace(/[&%$#@!]/g, '')           // Remove special symbols
    .replace(/\s+/g, ' ')               // Final whitespace collapse

    // STEP 3: Limit length
    .trim()
    .substring(0, 80);                  // Strict 80 char limit for safety
}

// Generator 1: System Context
export function generateSystemContextDiagram(data: Partial<ArchitectureData>): string {
  const { projectInfo, actors, externalSystems } = data;

  if (!projectInfo?.projectName || !actors?.length) return '';

  const actorsBlock = actors
    .map((actor, idx) => {
      const activities = actor.activities.slice(0, 3).join('<br/>‚Ä¢ ');
      const actorName = sanitizeForMermaid(actor.name);
      const actorRole = sanitizeForMermaid(actor.role);
      const activitiesText = activities ? '<br/><br/>‚Ä¢ ' + sanitizeForMermaid(activities) : '';
      return `        A${idx}[${actorName}<br/>${actorRole}${activitiesText}]`;
    })
    .join('\n');

  const projectName = sanitizeForMermaid(projectInfo.projectName);
  const projectDesc = projectInfo.description ? '<br/><br/>' + sanitizeForMermaid(projectInfo.description) : '';
  const systemBlock = `    SYS[${projectName}${projectDesc}]`;

  const externalBlock = externalSystems
    ?.map((sys, idx) => {
      const sysName = sanitizeForMermaid(sys.name);
      const sysPurpose = sanitizeForMermaid(sys.purpose);
      const shape = sys.type.toLowerCase().includes('database')
        ? `[(${sysName}<br/>${sysPurpose})]`
        : `[${sysName}<br/>${sysPurpose}]`;
      return `        EXT${idx}${shape}`;
    })
    .join('\n') || '';

  const actorConnections = actors.map((actor, idx) => {
    const lineStyle = actor.state === 'planned' ? '-.->' : '-->';
    return `    A${idx} ${lineStyle} SYS`;
  }).join('\n');

  const externalConnections = externalSystems
    ?.map((sys, idx) => {
      const integration = sanitizeForMermaid(sys.integration);
      const lineStyle = sys.state === 'planned' ? '-.->': '-->';
      const connector = integration ? `${lineStyle}|${integration}|` : lineStyle;
      return `    SYS ${connector} EXT${idx}`;
    })
    .join('\n') || '';

  // Style planned items differently
  const actorStyles = actors.map((actor, idx) =>
    actor.state === 'planned'
      ? `    style A${idx} stroke-dasharray: 5 5,stroke:#9CA3AF`
      : ''
  ).filter(Boolean).join('\n');

  const externalStyles = externalSystems
    ?.map((sys, idx) =>
      sys.state === 'planned'
        ? `    style EXT${idx} stroke-dasharray: 5 5,stroke:#9CA3AF`
        : ''
    )
    .filter(Boolean)
    .join('\n') || '';

  return `graph TB
    subgraph "Actors / Users"
${actorsBlock}
    end

    ${systemBlock}

    subgraph "External Systems"
${externalBlock}
    end

${actorConnections}
${externalConnections}

    style SYS fill:#4F46E5,stroke:#4338CA,stroke-width:3px,color:#fff
${actorStyles}
${externalStyles}`;
}

// Generator 2: Module Architecture
export function generateModuleArchitectureDiagram(data: Partial<ArchitectureData>): string {
  const { moduleAreas, database, integrationLayer } = data;

  if (!moduleAreas?.length || !database?.type) return '';

  const moduleBlocks = moduleAreas
    .map((area, areaIdx) => {
      const areaName = sanitizeForMermaid(area.area);
      const modules = area.modules
        .map((mod, modIdx) => {
          const id = `mod${areaIdx}${modIdx}`;
          const code = sanitizeForMermaid(mod.code);
          const name = sanitizeForMermaid(mod.name);
          const scope = mod.scope ? `<br/><br/>${sanitizeForMermaid(mod.scope)}` : '';
          return `        ${id}[${code} - ${name}${scope}]`;
        })
        .join('\n');

      return `    subgraph area${areaIdx}["${areaName}"]
${modules}
    end`;
    })
    .join('\n\n');

  const dbType = sanitizeForMermaid(database.type);
  const dbSize = database.size ? '<br/>' + sanitizeForMermaid(database.size) : '';
  const dbBlock = `    database[(${dbType}${dbSize})]`;

  const intBlock =
    integrationLayer?.middleware &&
    `    middleware[${sanitizeForMermaid(integrationLayer.middleware)}<br/>${sanitizeForMermaid(integrationLayer.description || '')}]`;

  const allModules = moduleAreas.flatMap((area) => area.modules);
  const moduleIds = moduleAreas.flatMap((area, areaIdx) =>
    area.modules.map((mod, modIdx) => ({ id: `mod${areaIdx}${modIdx}`, state: mod.state }))
  );

  const connections = moduleIds.map(({ id, state }) => {
    const lineStyle = state === 'planned' ? '-.->' : '-->';
    return `    ${id} ${lineStyle} database`;
  }).join('\n');

  const intConnections = intBlock
    ? moduleIds.map(({ id, state }) => {
        const lineStyle = state === 'planned' ? '-.->' : '-->';
        return `    ${id} ${lineStyle} middleware`;
      }).join('\n')
    : '';

  // Style planned modules differently
  const moduleStyles = moduleIds.map(({ id, state }) =>
    state === 'planned'
      ? `    style ${id} stroke-dasharray: 5 5,stroke:#9CA3AF`
      : ''
  ).filter(Boolean).join('\n');

  return `graph TB
${moduleBlocks}

    ${intBlock || ''}
    ${dbBlock}

${connections}
${intConnections}

    style database fill:#10B981,stroke:#059669,stroke-width:2px,color:#fff
${moduleStyles}`;
}

// Generator 3: Integration Architecture
export function generateIntegrationArchitectureDiagram(data: Partial<ArchitectureData>): string {
  const { interfaces } = data;

  // Only show interfaces that have at least name, source, and target
  const validInterfaces = interfaces?.filter(
    (iface) => iface.name && iface.source && iface.target
  );

  if (!validInterfaces || validInterfaces.length === 0) return '';

  // Helper to sanitize participant names and ensure they're valid
  const sanitizeParticipantName = (name: string): string => {
    const sanitized = name.replace(/[^a-zA-Z0-9]/g, '_');
    // Ensure it starts with a letter (Mermaid requirement)
    return /^[a-zA-Z]/.test(sanitized) ? sanitized : `P_${sanitized}`;
  };

  const participants = new Set<string>();
  validInterfaces.forEach((iface) => {
    const source = sanitizeParticipantName(iface.source);
    const target = sanitizeParticipantName(iface.target);
    participants.add(source);
    participants.add(target);
  });

  const participantBlock = Array.from(participants)
    .filter(p => p && p.length > 0)
    .map((p) => `    participant ${p}`)
    .join('\n');

  const flows = validInterfaces
    .map((iface) => {
      const source = sanitizeParticipantName(iface.source);
      const target = sanitizeParticipantName(iface.target);

      // Build label with only available information
      const labelParts = [];
      if (iface.method) labelParts.push(sanitizeForMermaid(iface.method));
      if (iface.dataType) labelParts.push(sanitizeForMermaid(iface.dataType));
      if (iface.frequency) labelParts.push(sanitizeForMermaid(iface.frequency));

      const label = labelParts.length > 0 ? labelParts.join(' | ') : sanitizeForMermaid(iface.name);

      // Use dashed lines for planned integrations
      const arrow = iface.state === 'planned' ? '-->>': '->>';
      const stateIndicator = iface.state === 'planned' ? ' [PLANNED]' : '';

      return `    ${source}${arrow}${target}: ${label}${stateIndicator}`;
    })
    .join('\n');

  return `sequenceDiagram
${participantBlock}

${flows}`;
}

// Generator 4: Deployment Architecture
export function generateDeploymentArchitectureDiagram(data: Partial<ArchitectureData>): string {
  const { environments, infrastructure } = data;

  if (!environments?.length || !infrastructure?.deploymentModel) return '';

  const envBlocks = environments
    .map((env, idx) => {
      const envName = sanitizeForMermaid(env.name);
      const servers = env.servers
        .map((srv, srvIdx) => {
          const id = `env${idx}srv${srvIdx}`;
          const srvType = sanitizeForMermaid(srv.type);
          const srvSpecs = sanitizeForMermaid(srv.specs);
          const shape =
            srv.type.toLowerCase().includes('database') || srv.type.toLowerCase().includes('db')
              ? `[(${srvType}<br/>${srv.count}x ${srvSpecs})]`
              : `[${srvType}<br/>${srv.count}x ${srvSpecs}]`;
          return `        ${id}${shape}`;
        })
        .join('\n');

      return `    subgraph env${idx}["${envName}"]
${servers}
    end`;
    })
    .join('\n\n');

  const location = sanitizeForMermaid(infrastructure.location);
  const deploymentModel = sanitizeForMermaid(infrastructure.deploymentModel);
  const infraInfo = `    infraInfo["üìç ${location}<br/>üì¶ ${deploymentModel}"]`;

  return `graph TB
${envBlocks}

    ${infraInfo}

    style infraInfo fill:#F59E0B,stroke:#D97706,stroke-width:2px,color:#000`;
}

// Generator 5: Security Architecture
export function generateSecurityArchitectureDiagram(data: Partial<ArchitectureData>): string {
  const { authMethods, securityControls, compliance } = data;

  if (!authMethods?.length || !securityControls?.length) return '';

  const authBlock = `    subgraph auth["Authentication"]
${authMethods.map((auth, idx) => {
      const method = sanitizeForMermaid(auth.method);
      const provider = sanitizeForMermaid(auth.provider);
      return `        auth${idx}["üîê ${method}<br/>${provider}"]`;
    }).join('\n')}
    end`;

  const secBlocks = securityControls
    .map((ctrl, idx) => {
      const layer = sanitizeForMermaid(ctrl.layer);
      const controls = ctrl.controls
        .slice(0, 3)
        .map((c, cidx) => `        sec${idx}ctrl${cidx}["üõ°Ô∏è ${sanitizeForMermaid(c)}"]`)
        .join('\n');
      return `    subgraph sec${idx}["${layer}"]
${controls}
    end`;
    })
    .join('\n\n');

  const compBlock =
    compliance?.standards.length &&
    `    compli["üìã Compliance:<br/>${compliance.standards.slice(0, 2).map(s => sanitizeForMermaid(s)).join('<br/>')}"]`;

  const firstSecCtrl = securityControls[0] ? `sec0ctrl0` : `auth0`;

  return `graph TB
    internet["üåê Internet"]

${secBlocks}

${authBlock}

    ${compBlock || ''}

    internet --> ${firstSecCtrl}

    style compli fill:#10B981,stroke:#059669,stroke-width:2px,color:#fff`;
}

// Generator 6: Sizing & Scalability
export function generateSizingScalabilityDiagram(data: Partial<ArchitectureData>): string {
  const { phases, scalability } = data;

  if (!phases?.length) return '';

  const phaseBlocks = phases
    .map((phase, idx) => {
      const phaseName = sanitizeForMermaid(phase.name);
      const phaseTimeline = sanitizeForMermaid(phase.timeline);
      const txSummary = phase.transactions
        .slice(0, 2)
        .map((t) => `${sanitizeForMermaid(t.type)}: ${sanitizeForMermaid(t.volume)}`)
        .join('<br/>');
      return `        P${idx}["üìä ${phaseName}<br/>üë• ${phase.users} users<br/>‚è±Ô∏è ${phaseTimeline}${
        txSummary ? '<br/><br/>' + txSummary : ''
      }"]`;
    })
    .join('\n');

  const scaleBlock =
    scalability?.approach &&
    `    SCALE["üìà Scalability:<br/>${sanitizeForMermaid(scalability.approach)}<br/>Limits: ${sanitizeForMermaid(scalability.limits)}"]`;

  const connections = phases
    .map((_, idx) => (idx < phases.length - 1 ? `    P${idx} --> P${idx + 1}` : ''))
    .filter(Boolean)
    .join('\n');

  const finalConnection = scaleBlock ? `    P${phases.length - 1} --> SCALE` : '';

  return `graph LR
    subgraph "Growth Phases"
${phaseBlocks}
    end

    ${scaleBlock || ''}

${connections}
${finalConnection}

    style SCALE fill:#10B981,stroke:#059669,stroke-width:2px,color:#fff`;
}
