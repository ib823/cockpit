/**
 * EXCEL EXPORT UTILITY
 *
 * Exports project data to Excel format for sharing with stakeholders
 * Uses SheetJS (xlsx) library for Excel generation
 */

import * as XLSX from 'xlsx';
import type { Phase } from '@/types/core';
import type { Chip } from '@/types/core';
import { formatCurrency, formatDuration } from '@/lib/utils';
import { format } from 'date-fns';

export interface ExportData {
  projectName: string;
  chips: Chip[];
  phases: Phase[];
  decisions?: Record<string, any>;
  totalCost: number;
  totalDuration: number;
  metadata?: {
    generatedAt: Date;
    generatedBy: string;
    version: string;
  };
}

/**
 * Export project data to Excel file
 */
export async function exportToExcel(data: ExportData): Promise<void> {
  const workbook = XLSX.utils.book_new();

  // Sheet 1: Project Summary
  const summarySheet = createSummarySheet(data);
  XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

  // Sheet 2: Timeline & Phases
  const timelineSheet = createTimelineSheet(data.phases);
  XLSX.utils.book_append_sheet(workbook, timelineSheet, 'Timeline');

  // Sheet 3: Cost Breakdown
  const costSheet = createCostBreakdownSheet(data.phases, data.totalCost);
  XLSX.utils.book_append_sheet(workbook, costSheet, 'Cost Breakdown');

  // Sheet 4: Requirements (Chips)
  if (data.chips.length > 0) {
    const requirementsSheet = createRequirementsSheet(data.chips);
    XLSX.utils.book_append_sheet(workbook, requirementsSheet, 'Requirements');
  }

  // Sheet 5: Decisions
  if (data.decisions && Object.keys(data.decisions).length > 0) {
    const decisionsSheet = createDecisionsSheet(data.decisions);
    XLSX.utils.book_append_sheet(workbook, decisionsSheet, 'Decisions');
  }

  // Generate filename with timestamp
  const timestamp = format(new Date(), 'yyyy-MM-dd_HHmm');
  const filename = `${sanitizeFilename(data.projectName)}_${timestamp}.xlsx`;

  // Write file
  XLSX.writeFile(workbook, filename);
}

/**
 * Create Summary sheet
 */
function createSummarySheet(data: ExportData): XLSX.WorkSheet {
  const rows: any[][] = [
    ['SAP IMPLEMENTATION PROJECT SUMMARY'],
    [],
    ['Project Name', data.projectName],
    ['Generated On', format(data.metadata?.generatedAt || new Date(), 'PPpp')],
    ['Generated By', data.metadata?.generatedBy || 'SAP Implementation Cockpit'],
    [],
    ['OVERVIEW'],
    ['Total Duration', formatDuration(data.totalDuration)],
    ['Total Cost (MYR)', formatCurrency(data.totalCost, 'MYR')],
    ['Number of Phases', data.phases.length],
    ['Number of Requirements', data.chips.length],
    [],
    ['PHASE SUMMARY'],
    ...data.phases.map((phase, idx) => [
      `Phase ${idx + 1}`,
      phase.name,
      `${phase.workingDays} days`,
      phase.resources?.length || 0,
    ]),
  ];

  const worksheet = XLSX.utils.aoa_to_sheet(rows);

  // Set column widths
  worksheet['!cols'] = [
    { wch: 25 }, // Column A
    { wch: 40 }, // Column B
    { wch: 20 }, // Column C
    { wch: 15 }, // Column D
  ];

  // Style the header row
  if (worksheet['A1']) {
    worksheet['A1'].s = {
      font: { bold: true, sz: 16 },
      alignment: { horizontal: 'left' },
    };
  }

  return worksheet;
}

/**
 * Create Timeline sheet
 */
function createTimelineSheet(phases: Phase[]): XLSX.WorkSheet {
  const headers = [
    'Phase #',
    'Phase Name',
    'Category',
    'Start Date',
    'End Date',
    'Duration (Days)',
    'Effort (Man-days)',
    'Team Size',
    'Status',
  ];

  const rows = phases.map((phase, idx) => [
    idx + 1,
    phase.name,
    phase.category || 'N/A',
    phase.startDate ? format(phase.startDate, 'MMM dd, yyyy') : 'TBD',
    phase.endDate ? format(phase.endDate, 'MMM dd, yyyy') : 'TBD',
    phase.workingDays,
    phase.effort || 0,
    phase.resources?.length || 0,
    phase.status || 'Not Started',
  ]);

  const worksheet = XLSX.utils.aoa_to_sheet([headers, ...rows]);

  // Set column widths
  worksheet['!cols'] = [
    { wch: 10 },  // Phase #
    { wch: 30 },  // Phase Name
    { wch: 20 },  // Category
    { wch: 15 },  // Start Date
    { wch: 15 },  // End Date
    { wch: 15 },  // Duration
    { wch: 18 },  // Effort
    { wch: 12 },  // Team Size
    { wch: 15 },  // Status
  ];

  // Bold header row
  headers.forEach((_, colIdx) => {
    const cellRef = XLSX.utils.encode_cell({ r: 0, c: colIdx });
    if (worksheet[cellRef]) {
      worksheet[cellRef].s = { font: { bold: true } };
    }
  });

  return worksheet;
}

/**
 * Create Cost Breakdown sheet
 */
function createCostBreakdownSheet(phases: Phase[], totalCost: number): XLSX.WorkSheet {
  const headers = [
    'Phase',
    'Resource',
    'Role',
    'Allocation (%)',
    'Hourly Rate (MYR)',
    'Duration (Days)',
    'Total Hours',
    'Cost (MYR)',
  ];

  const rows: any[][] = [];
  let runningTotal = 0;

  phases.forEach((phase) => {
    if (phase.resources && phase.resources.length > 0) {
      phase.resources.forEach((resource: any) => {
        const totalHours = phase.workingDays * 8 * (resource.allocation / 100);
        const cost = totalHours * resource.hourlyRate;
        runningTotal += cost;

        rows.push([
          phase.name,
          resource.name || 'TBD',
          resource.role,
          resource.allocation,
          resource.hourlyRate,
          phase.workingDays,
          totalHours.toFixed(1),
          cost.toFixed(2),
        ]);
      });
    }
  });

  // Add totals row
  rows.push([]);
  rows.push([
    'TOTAL PROJECT COST',
    '',
    '',
    '',
    '',
    '',
    '',
    totalCost.toFixed(2),
  ]);

  const worksheet = XLSX.utils.aoa_to_sheet([headers, ...rows]);

  // Set column widths
  worksheet['!cols'] = [
    { wch: 25 },  // Phase
    { wch: 20 },  // Resource
    { wch: 25 },  // Role
    { wch: 15 },  // Allocation
    { wch: 18 },  // Hourly Rate
    { wch: 15 },  // Duration
    { wch: 15 },  // Total Hours
    { wch: 18 },  // Cost
  ];

  // Bold header row
  headers.forEach((_, colIdx) => {
    const cellRef = XLSX.utils.encode_cell({ r: 0, c: colIdx });
    if (worksheet[cellRef]) {
      worksheet[cellRef].s = { font: { bold: true } };
    }
  });

  // Bold total row
  const totalRowIdx = rows.length;
  const totalCellRef = XLSX.utils.encode_cell({ r: totalRowIdx, c: 0 });
  if (worksheet[totalCellRef]) {
    worksheet[totalCellRef].s = { font: { bold: true } };
  }

  return worksheet;
}

/**
 * Create Requirements sheet
 */
function createRequirementsSheet(chips: Chip[]): XLSX.WorkSheet {
  const headers = [
    'Type',
    'Value',
    'Confidence',
    'Source',
    'Validated',
  ];

  const rows = chips.map((chip) => [
    chip.type,
    chip.value,
    chip.confidence ? `${(chip.confidence * 100).toFixed(0)}%` : 'N/A',
    chip.source || 'Manual',
    chip.validated ? 'Yes' : 'No',
  ]);

  const worksheet = XLSX.utils.aoa_to_sheet([headers, ...rows]);

  // Set column widths
  worksheet['!cols'] = [
    { wch: 20 },  // Type
    { wch: 50 },  // Value
    { wch: 12 },  // Confidence
    { wch: 15 },  // Source
    { wch: 12 },  // Validated
  ];

  // Bold header row
  headers.forEach((_, colIdx) => {
    const cellRef = XLSX.utils.encode_cell({ r: 0, c: colIdx });
    if (worksheet[cellRef]) {
      worksheet[cellRef].s = { font: { bold: true } };
    }
  });

  return worksheet;
}

/**
 * Create Decisions sheet
 */
function createDecisionsSheet(decisions: Record<string, any>): XLSX.WorkSheet {
  const rows: any[][] = [
    ['STRATEGIC DECISIONS'],
    [],
    ['Decision', 'Value'],
  ];

  // Map decision keys to readable names
  const decisionLabels: Record<string, string> = {
    moduleCombo: 'Module Combination',
    pricingModel: 'Pricing Model',
    ssoMode: 'SSO Authentication',
    deploymentMode: 'Deployment Mode',
    complianceLevel: 'Compliance Level',
    modules: 'Selected Modules',
    complexity: 'Project Complexity',
  };

  Object.entries(decisions).forEach(([key, value]) => {
    const label = decisionLabels[key] || key;
    let displayValue = value;

    // Format array values
    if (Array.isArray(value)) {
      displayValue = value.join(', ');
    }

    rows.push([label, displayValue]);
  });

  const worksheet = XLSX.utils.aoa_to_sheet(rows);

  // Set column widths
  worksheet['!cols'] = [
    { wch: 30 },  // Decision
    { wch: 50 },  // Value
  ];

  // Bold title
  if (worksheet['A1']) {
    worksheet['A1'].s = { font: { bold: true, sz: 14 } };
  }

  // Bold headers
  if (worksheet['A3']) {
    worksheet['A3'].s = { font: { bold: true } };
  }
  if (worksheet['B3']) {
    worksheet['B3'].s = { font: { bold: true } };
  }

  return worksheet;
}

/**
 * Sanitize filename for safe file system usage
 */
function sanitizeFilename(name: string): string {
  return name
    .replace(/[^a-z0-9]/gi, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '')
    .substring(0, 50) || 'project';
}

/**
 * Export to CSV (single sheet alternative)
 */
export async function exportToCSV(
  data: any[][],
  filename: string
): Promise<void> {
  const worksheet = XLSX.utils.aoa_to_sheet(data);
  const csvContent = XLSX.utils.sheet_to_csv(worksheet);

  // Create blob and download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', `${sanitizeFilename(filename)}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
