/**
 * EXCEL EXPORT UTILITY
 *
 * Exports project data to Excel format for sharing with stakeholders
 * Uses ExcelJS library (secure, actively maintained)
 */

"use client";

import type { Phase } from "@/types/core";
import type { Chip } from "@/types/core";
import { formatCurrency, formatDuration } from "@/lib/utils";
import { format } from "date-fns";

export interface ExportData {
  projectName: string;
  chips: Chip[];
  phases: Phase[];
  decisions?: Record<string, any>;
  totalCost: number;
  totalDuration: number;
  metadata?: {
    generatedAt: Date;
    generatedBy: string;
    version: string;
  };
}

/**
 * Export project data to Excel file
 */
export async function exportToExcel(data: ExportData): Promise<void> {
  // Dynamic import to avoid bundling in SSR
  const ExcelJS = await import("exceljs");
  const workbook = new ExcelJS.Workbook();

  // Set workbook properties
  workbook.creator = "Bound";
  workbook.created = new Date();

  // Sheet 1: Project Summary
  createSummarySheet(workbook, data);

  // Sheet 2: Timeline & Phases
  createTimelineSheet(workbook, data.phases);

  // Sheet 3: Cost Breakdown
  createCostBreakdownSheet(workbook, data.phases, data.totalCost);

  // Sheet 4: Requirements (Chips)
  if (data.chips.length > 0) {
    createRequirementsSheet(workbook, data.chips);
  }

  // Sheet 5: Decisions
  if (data.decisions && Object.keys(data.decisions).length > 0) {
    createDecisionsSheet(workbook, data.decisions);
  }

  // Generate filename with timestamp
  const timestamp = format(new Date(), "yyyy-MM-dd_HHmm");
  const filename = `${sanitizeFilename(data.projectName)}_${timestamp}.xlsx`;

  // Write file
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], {
    type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  });

  // Download file
  const link = document.createElement("a");
  const url = URL.createObjectURL(blob);
  link.href = url;
  link.download = filename;
  link.click();
  URL.revokeObjectURL(url);
}

/**
 * Create Summary sheet
 */
function createSummarySheet(workbook: any, data: ExportData): void {
  const worksheet = workbook.addWorksheet("Summary");

  // Add title
  worksheet.addRow(["SAP IMPLEMENTATION PROJECT SUMMARY"]);
  worksheet.getRow(1).font = { bold: true, size: 16 };
  worksheet.addRow([]);

  // Add basic info
  worksheet.addRow(["Project Name", data.projectName]);
  worksheet.addRow(["Generated On", format(data.metadata?.generatedAt || new Date(), "PPpp")]);
  worksheet.addRow(["Generated By", data.metadata?.generatedBy || "Bound"]);
  worksheet.addRow([]);

  // Add overview
  worksheet.addRow(["OVERVIEW"]);
  worksheet.getRow(7).font = { bold: true };
  worksheet.addRow(["Total Duration", formatDuration(data.totalDuration)]);
  worksheet.addRow(["Total Cost (MYR)", formatCurrency(data.totalCost, "MYR")]);
  worksheet.addRow(["Number of Phases", data.phases.length]);
  worksheet.addRow(["Number of Requirements", data.chips.length]);
  worksheet.addRow([]);

  // Add phase summary
  worksheet.addRow(["PHASE SUMMARY"]);
  worksheet.getRow(13).font = { bold: true };
  data.phases.forEach((phase, idx) => {
    worksheet.addRow([
      `Phase ${idx + 1}`,
      phase.name,
      `${phase.workingDays} days`,
      phase.resources?.length || 0,
    ]);
  });

  // Set column widths
  worksheet.getColumn(1).width = 25;
  worksheet.getColumn(2).width = 40;
  worksheet.getColumn(3).width = 20;
  worksheet.getColumn(4).width = 15;
}

/**
 * Create Timeline sheet
 */
function createTimelineSheet(workbook: any, phases: Phase[]): void {
  const worksheet = workbook.addWorksheet("Timeline");

  // Add headers
  const headers = [
    "Phase #",
    "Phase Name",
    "Category",
    "Start Date",
    "End Date",
    "Duration (Days)",
    "Effort (Man-days)",
    "Team Size",
    "Status",
  ];
  worksheet.addRow(headers);
  worksheet.getRow(1).font = { bold: true };

  // Add data
  phases.forEach((phase, idx) => {
    worksheet.addRow([
      idx + 1,
      phase.name,
      phase.category || "N/A",
      phase.startDate ? format(phase.startDate, "dd-MMM-yy (EEE)") : "TBD",
      phase.endDate ? format(phase.endDate, "dd-MMM-yy (EEE)") : "TBD",
      phase.workingDays,
      phase.effort || 0,
      phase.resources?.length || 0,
      phase.status || "Not Started",
    ]);
  });

  // Set column widths
  worksheet.getColumn(1).width = 10; // Phase #
  worksheet.getColumn(2).width = 30; // Phase Name
  worksheet.getColumn(3).width = 20; // Category
  worksheet.getColumn(4).width = 15; // Start Date
  worksheet.getColumn(5).width = 15; // End Date
  worksheet.getColumn(6).width = 15; // Duration
  worksheet.getColumn(7).width = 18; // Effort
  worksheet.getColumn(8).width = 12; // Team Size
  worksheet.getColumn(9).width = 15; // Status
}

/**
 * Create Cost Breakdown sheet
 */
function createCostBreakdownSheet(workbook: any, phases: Phase[], totalCost: number): void {
  const worksheet = workbook.addWorksheet("Cost Breakdown");

  // Add headers
  const headers = [
    "Phase",
    "Resource",
    "Role",
    "Allocation (%)",
    "Hourly Rate (MYR)",
    "Duration (Days)",
    "Total Hours",
    "Cost (MYR)",
  ];
  worksheet.addRow(headers);
  worksheet.getRow(1).font = { bold: true };

  // Add data
  let runningTotal = 0;
  phases.forEach((phase) => {
    if (phase.resources && phase.resources.length > 0) {
      phase.resources.forEach((resource: any) => {
        const totalHours = phase.workingDays * 8 * (resource.allocation / 100);
        const cost = totalHours * resource.hourlyRate;
        runningTotal += cost;

        worksheet.addRow([
          phase.name,
          resource.name || "TBD",
          resource.role,
          resource.allocation,
          resource.hourlyRate,
          phase.workingDays,
          parseFloat(totalHours.toFixed(1)),
          parseFloat(cost.toFixed(2)),
        ]);
      });
    }
  });

  // Add totals row
  worksheet.addRow([]);
  const totalRow = worksheet.addRow([
    "TOTAL PROJECT COST",
    "",
    "",
    "",
    "",
    "",
    "",
    parseFloat(totalCost.toFixed(2)),
  ]);
  totalRow.font = { bold: true };

  // Set column widths
  worksheet.getColumn(1).width = 25;
  worksheet.getColumn(2).width = 20;
  worksheet.getColumn(3).width = 25;
  worksheet.getColumn(4).width = 15;
  worksheet.getColumn(5).width = 18;
  worksheet.getColumn(6).width = 15;
  worksheet.getColumn(7).width = 15;
  worksheet.getColumn(8).width = 18;
}

/**
 * Create Requirements sheet
 */
function createRequirementsSheet(workbook: any, chips: Chip[]): void {
  const worksheet = workbook.addWorksheet("Requirements");

  // Add headers
  const headers = ["Type", "Value", "Confidence", "Source", "Validated"];
  worksheet.addRow(headers);
  worksheet.getRow(1).font = { bold: true };

  // Add data
  chips.forEach((chip) => {
    worksheet.addRow([
      chip.type,
      chip.value,
      chip.confidence ? `${(chip.confidence * 100).toFixed(0)}%` : "N/A",
      chip.source || "Manual",
      chip.validated ? "Yes" : "No",
    ]);
  });

  // Set column widths
  worksheet.getColumn(1).width = 20;
  worksheet.getColumn(2).width = 50;
  worksheet.getColumn(3).width = 12;
  worksheet.getColumn(4).width = 15;
  worksheet.getColumn(5).width = 12;
}

/**
 * Create Decisions sheet
 */
function createDecisionsSheet(workbook: any, decisions: Record<string, any>): void {
  const worksheet = workbook.addWorksheet("Decisions");

  // Add title
  worksheet.addRow(["STRATEGIC DECISIONS"]);
  worksheet.getRow(1).font = { bold: true, size: 14 };
  worksheet.addRow([]);

  // Add headers
  worksheet.addRow(["Decision", "Value"]);
  worksheet.getRow(3).font = { bold: true };

  // Map decision keys to readable names
  const decisionLabels: Record<string, string> = {
    moduleCombo: "Module Combination",
    pricingModel: "Pricing Model",
    ssoMode: "SSO Authentication",
    deploymentMode: "Deployment Mode",
    complianceLevel: "Compliance Level",
    modules: "Selected Modules",
    complexity: "Project Complexity",
  };

  // Add data
  Object.entries(decisions).forEach(([key, value]) => {
    const label = decisionLabels[key] || key;
    let displayValue = value;

    // Format array values
    if (Array.isArray(value)) {
      displayValue = value.join(", ");
    }

    worksheet.addRow([label, displayValue]);
  });

  // Set column widths
  worksheet.getColumn(1).width = 30;
  worksheet.getColumn(2).width = 50;
}

/**
 * Sanitize filename for safe file system usage
 */
function sanitizeFilename(name: string): string {
  return (
    name
      .replace(/[^a-z0-9]/gi, "_")
      .replace(/_+/g, "_")
      .replace(/^_|_$/g, "")
      .substring(0, 50) || "project"
  );
}

/**
 * Export to CSV (single sheet alternative)
 */
export async function exportToCSV(data: any[][], filename: string): Promise<void> {
  // Convert data to CSV
  const csvContent = data.map((row) => row.map((cell) => `"${cell}"`).join(",")).join("\n");

  // Create blob and download
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  const url = URL.createObjectURL(blob);

  link.setAttribute("href", url);
  link.setAttribute("download", `${sanitizeFilename(filename)}.csv`);
  link.style.visibility = "hidden";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
